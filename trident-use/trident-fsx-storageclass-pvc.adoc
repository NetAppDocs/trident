---
sidebar: sidebar
permalink: trident-use/trident-fsx-storageclass-pvc.html
keywords: Amazon FSx for NetApp ONTAP, FSx for ONTAP, deploy Trident, integrate Trident, Trident
summary: Using Astra Trident with Amazon FSx for NetApp ONTAP, you can ensure that your Kubernetes clusters running in Amazon Elastic Kubernetes Service (EKS) can provision block and file persistent volumes backed by ONTAP.
---

= Configure a storage class and PVC
:hardbreaks:
:icons: font
:imagesdir: ../media/

[.lead]
Configure a Kubernetes StorageClass object and create the storage class to instruct Astra Trident how to provision volumes. Create a PersistentVolume (PV) and a PersistentVolumeClaim (PVC) that uses the configured Kubernetes StorageClass to request access to the PV. You can then mount the PV to a pod.

== Create a storage class

=== Configure a Kubernetes StorageClass object
The https://kubernetes.io/docs/concepts/storage/storage-classes/[Kubernetes StorageClass object^] identifies Astra Trident as the provisioner that is used for that class instructs Astra Trident how to provision a volume. For example:

----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: <Name>
provisioner: csi.trident.netapp.io
mountOptions: <Mount Options>
parameters:
  <Trident Parameters>
allowVolumeExpansion: true
volumeBindingMode: Immediate
----

Refer to link:../trident-reference/objects.html[Kubernetes and Trident objects] for details on how storage classes interact with the `PersistentVolumeClaim` and parameters for controlling how Astra Trident provisions volumes. 

=== Create a storage class
After you create the StorageClass object, you can create the storage class. <<Storage class samples>> provides some basic samples you can use or modify.  

.Steps
. This is a Kubernetes object, so use `kubectl` to create it in Kubernetes.
+
----
kubectl create -f sample-input/storage-class-basic-csi.yaml
----

. You should now see a *basic-csi* storage class in both Kubernetes and Astra Trident, and Astra Trident should have discovered the pools on the backend.
+
----
kubectl get sc basic-csi
NAME         PROVISIONER             AGE
basic-csi    csi.trident.netapp.io   15h

./tridentctl -n trident get storageclass basic-csi -o json
{
  "items": [
    {
      "Config": {
        "version": "1",
        "name": "basic-csi",
        "attributes": {
          "backendType": "ontap-nas"
        },
        "storagePools": null,
        "additionalStoragePools": null
      },
      "storage": {
        "ontapnas_10.0.0.1": [
          "aggr1",
          "aggr2",
          "aggr3",
          "aggr4"
        ]
      }
    }
  ]
}
----

==== Storage class samples
Astra Trident provides https://github.com/NetApp/trident/tree/master/trident-installer/sample-input/storage-class-samples[simple storage class definitions for specific backends^].

Alternatively, you can edit `sample-input/storage-class-csi.yaml.templ` file that comes with the installer and replace `__BACKEND_TYPE__` with the storage driver name.
----
./tridentctl -n trident get backend
+-------------+----------------+--------------------------------------+--------+---------+
|    NAME     | STORAGE DRIVER |                 UUID                 | STATE  | VOLUMES |
+-------------+----------------+--------------------------------------+--------+---------+
| nas-backend | ontap-nas      | 98e19b74-aec7-4a3d-8dcf-128e5033b214 | online |       0 |
+-------------+----------------+--------------------------------------+--------+---------+

cp sample-input/storage-class-csi.yaml.templ sample-input/storage-class-basic-csi.yaml

# Modify __BACKEND_TYPE__ with the storage driver field above (e.g., ontap-nas)
vi sample-input/storage-class-basic-csi.yaml
----

== Create the PV and PVC

A link:https://kubernetes.io/docs/concepts/storage/persistent-volumes/[_PersistentVolume_^] (PV) is a physical storage resource provisioned by the cluster administrator on a Kubernetes cluster. The https://kubernetes.io/docs/concepts/storage/persistent-volumes[_PersistentVolumeClaim_^] (PVC) is a request for access to the PersistentVolume on the cluster. 

The PVC can be configured to request storage of a certain size or access mode. Using the associated StorageClass, the cluster administrator can control more than PersistentVolume size and access mode--such as performance or service level. 

After you create the PV and PVC, you can mount the volume in a pod.

=== Sample manifests

.PersistentVolume sample manifest
[%collapsible]
====
This sample manifest shows a basic PV of 10Gi that is associated with StorageClass `basic-csi`.
----
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-storage
  labels:
    type: local
spec:
  storageClassName: basic-csi
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/my/host/path"
----
====

.PersistentVolumeClaim sample manifests
[%collapsible]
====
These examples show basic PVC configuration options. 

.PVC with RWO access
This example shows a basic PVC with RWO access that is associated with a StorageClass named `basic-csi`.
----
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: pvc-storage
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: basic-csi
----

.PVC with NVMe/TCP
This example shows a basic PVC for NVMe/TCP with RWO access that is associated with a StorageClass named `protection-gold`.
----
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
name: pvc-san-nvme
spec:
accessModes:
  - ReadWriteOnce
resources:
  requests:
    storage: 300Mi
storageClassName: protection-gold
----
====

.Pod manifest samples
[%collapsible]
====
These examples show basic configurations to attach the PVC to a pod. 

.Basic configuration
----
kind: Pod
apiVersion: v1
metadata:
  name: pv-pod
spec:
  volumes:
    - name: pv-storage
      persistentVolumeClaim:
       claimName: basic
  containers:
    - name: pv-container
      image: nginx
      ports:
        - containerPort: 80
          name: "http-server"
      volumeMounts:
        - mountPath: "/my/mount/path"
          name: pv-storage
----

.Basic NVMe/TCP configuration
----
---
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
    - image: nginx
      name: nginx
      resources: {}
      volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: task-pv-storage
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  volumes:
    - name: task-pv-storage
      persistentVolumeClaim:
      claimName: pvc-san-nvme
----
====

=== Create the PV and PVC


.Steps
. Create the PV.
+
----
kubectl create -f pv.yaml
----
. Verify the PV status.
+
----
kubectl get pv
NAME        CAPACITY  ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM  STORAGECLASS  REASON  AGE
pv-storage  4Gi       RWO           Retain          Available                              7s
----
. Create the PVC.
+
----
kubectl create -f pvc.yaml
----
. Verify the PVC status.
+
----
kubectl get pvc
NAME        STATUS VOLUME     CAPACITY ACCESS MODES STORAGECLASS AGE
pvc-storage Bound  pv-name 2Gi      RWO                       5m
----
. Mount the volume in a pod.
+
----
kubectl create -f pv-pod.yaml
----
+
NOTE: You can monitor the progress using `kubectl get pod --watch`.
. Verify that the volume is mounted on `/my/mount/path`.
+
----
kubectl exec -it task-pv-pod -- df -h /my/mount/path
----
. You can now delete the Pod. The Pod application will no longer exist, but the volume will remain. 
+
----
kubectl delete pod task-pv-pod
----


Refer to link:../trident-reference/objects.html[Kubernetes and Trident objects] for details on how storage classes interact with the `PersistentVolumeClaim` and parameters for controlling how Astra Trident provisions volumes. 
